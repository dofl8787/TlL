0210 교수님 설명

![image-20220210090818684](C:\Users\kim\AppData\Roaming\Typora\typora-user-images\image-20220210090818684.png)

퀵 병합이 제일 빠름

카운팅 정렬 -> 속도가 빠르지만, 1차(n+k) 모든 경우에 범용적으로 적용할 수 없음 (적용이 제한적)

버블 정렬

!! 첫 번째 원소부터 인접한 원소끼리 비교를 한 다음, 교환할 필요가 있으면 계속 자리를 교환하며 맨 마지막 자리까지 이동한다 !!

-> 윗 줄을 반복하는 것

```
인접한 두 원소를 비교해서 교환
N개 일 때, N-1번 교환을 함 (비교 횟수 : N-1)

첫 시작이 i라면,
범위는 
i = 0 ~ (i-2)까지
(i와 i+1을 더해야하니, i-1이 범위라면 범위 초과)
```

```python
arr = [55, 7, 78, 12, 42]
N = len(arr)
for j in range (0, N-1):
    if arr[j] > arr[j+i] = arr[j+1], arr[j]
print(arr)
```

![image-20220210093209964](C:\Users\kim\AppData\Roaming\Typora\typora-user-images\image-20220210093209964.png)



여기서 제일 중요한 건 

counting 정렬



```
1. 인덱스의 값을 출력 값으로 쓸거임. [counting이니깐 0부터 N까지 차례대로 만들테니 index = 0~N으로 같으니까]
2. 그럼 N을 설정한다면, 우선적으로 알아야 할 것은? 
   => 자료의 최댓값을 찾기(0부터 N 까지닉간 ^^)
	: List [0]*(4+1) / (범위가 0~4까지 경우)
	리스트를 미리 만들어 놓는 것임(5개 ^^)
3. 
```

```python
a = [0, 4, 1, 3, 1, 2, 4, 1]

max_val = 4
C = [0] * (max_val + 1)

#카운팅
for val in A:
    C[val]+=1
    
#꼼수
#B = []
#for val, cnt in emumerate(C):
#    B += [val]*cnt
#print(B)
#=> 이렇게 하지 말기 ^^^^^^^^^

##카운트 누적
for i in range(1, max_val + 1):
    C[i] = C[i-1] + C[i]
princ(C)
#누적의 의미는?
# index가 1이면, C[1] -> C[0]+C[1]
# 
```





C에서의 max_val은



![image-20220210094909564](C:\Users\kim\AppData\Roaming\Typora\typora-user-images\image-20220210094909564.png)

```
모두 같은 0 하나를 참조하고 있음 후후
그래서 1을 ㄹ넣게 되면 두번째 칸이 1을 참조~
```



![image-20220210101413014](C:\Users\kim\AppData\Roaming\Typora\typora-user-images\image-20220210101413014.png)

```
index 1 = 4라면, 
1)1의 마지막 값은 4번째 자리에 위치하고 있음을 알 수 있다. 그래서 4번째 위치에 1 넣기
2) 맨 마지막 값, 마지막 자리에 넣기
3) 자리에 넣은 건 하나씩 빼면서 계산
```

![image-20220210101618689](C:\Users\kim\AppData\Roaming\Typora\typora-user-images\image-20220210101618689.png)

갯수가 끝나 있을 때, 누적 총합의 결과가 결국 각 숫자가 위치한 자리의 제일 끝부분들을 담당함



이를 코드로 옮기면

```python
A = [0, 4, 1, 3, 1, 2, 4, 1]
B = [0] * len[A]
max_val = 4
C = [0] * (max_val + 1)

#카운팅
for val in A:
    C[val]+=1
    
#꼼수
#B = []
#for val, cnt in emumerate(C):
#    B += [val]*cnt
#print(B)
#=> 이렇게 하지 마 ^^^^^^^^^

##카운트 누적
for i in range(1, max_val + 1):
    C[i] = C[i-1] + C[i]
    
#원본 자료 --> 새로운 공간에 옮기기
for i in range(len(A) - 1, -1, -1):
    C[A[i]] -= 1 #결국 쓰고, 1을 빼줄거니까 아예 1 씩 빼주기
    B[ C[A[i]] ] = A[i]
princ(C)
```

```
Q.마지막에 정렬할 때 data를 앞에서부터 읽어도 정렬이 가능한데 뒤에서 부터 읽는 게 더 안전한 이유는 무엇인가요? data케이스마다 다른 건 가요? 
A. 안정 정렬 때문 
안정 정렬 
정렬 하기 전 순서 앞에 있던 애가, 정렬이 끝나고도 순서상 앞에 위치해야 하는 걸 안정정렬이라고 함.
뒤에서부터 읽어서, 뒤에서부터 채우잖아 그렇죠?
뒤에서부터 읽고 채우기 때문에 그렇게 되겠지
그럴 이유가 있나요?
여기서는 구분이 안가서 상관 없지만
앞에서부터 채우려면 앞에서부터 읽어야 함
그럴 경우는 위 코드의 카운트 누적을 사용하지 않고, 다른 방법으로 사용
내가 정렬할 데이터가 값 하나가 아니라 여러개로 묶여 있는 걸 정리해야함 (ex.튜플 : (8,2), (8,1))
둘 중에 하나를 잡아서 정렬을 해야한다고 쳐
먼저 나오는 값을 잡아 정렬을 해야 한다고 쳐
카운팅 정렬을 사용할 수 있겠지
뒤에 나오는 값들이 이게 섞이면
순서가 달라지면
나온 순서와 달라지는게 정확하게 티가 남
나온 순서대로 정렬이 됐으면 좋겠음
위 방식대로 정렬을 한다면, 순서가 보장이 안됨
(앞에 있는게 뒤로 갈 테니까)
같은 기준으로 정렬 할 때, 같은 값일 때엔 입력되어 있는 순서대로 출력하길 원하기 때문에
사실은 앞에 있는 걸 뒤로 넣는 것(구분할 필요가 없으니까)
```



```python
#같은 값이 연속적으로 나오는 경우를 찾는다

arr = [0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0]

#값이 증가하는 길이가 최대인 경우를 찾는다
arr = [1, 2, 4, 7, 4, 2, 1, 4, 6, 8]


```



![image-20220210112516682](C:\Users\kim\AppData\Roaming\Typora\typora-user-images\image-20220210112516682.png)

view 내 코드보다 좀 더 좋은거

내가 확인하고 싶은 위치에서 부터 break point 걸고, 디버깅

바뀌는 걸 확인하면서 내가 계산한게 되고있나 확인 가능









![image-20220210164320389](C:\Users\kim\AppData\Roaming\Typora\typora-user-images\image-20220210164320389.png)



다음주 월요일에 수업

오늘 못하는 것들은 월, 화







