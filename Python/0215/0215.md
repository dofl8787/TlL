최대 최소 구하는 경우

1.리스트

: 이미 저장된 리스트 (자료들)에서 최대/최소 구하기

2.계산 과정에서 생성되는 값들 중에 최대/최소 구하기

초기값 설정

1 번의 경우는 초기값을 0번 인덱스의 값을 저장

2번의 경우:

 최댓값을 구할 땐 아주 작은 값, (제일 좋은 건 나올 수 있는 값의 범위를 추측 후, 가장 작은 값을 설정해주기)

ex) ans = -999999 같은 것들

최솟값을 구할 땐 아주 큰 값 설정. 그래야지 첫 번째 값을 비교하면서 바로 저장이 될테니까



im 시험 볼 때 코드 컴팩트하게 할 생각 말고, 그냥 순서대로 쭉 쓰세요 ^^~

다음주 알고 시험 (코딩) 할 땐 내장함수 금지가 있을것





---

버스

![image-20220215102555957](C:\Users\kim\AppData\Roaming\Typora\typora-user-images\image-20220215102555957.png)

이렇게도 가능하다

 



---

cos

부분집합의 합

이진 탐색 개념(문제 잘 읽어보기)

삽질 ->A,B 이진탐색 지정 페이지 찾아가기

숫자를 찾는 것 범위 안에 있는

이진 탐색 방법으로 

중간값을 제외를 안하고 중간값을 포함해서 진행

나중에 문제를 읽어보고 범위설정에 차이가 있다 ,,

특성에 맞게 풀어야 됨

특별한 정렬

선택 정렬 이용해서 풀어라(취지가)

다른 방법으로도 풀 수 있는데, 선택정렬 연습을 하라는 거기 때문에 선택정렬의 방식

selection algorithm 사용해라 (선택 알고리즘) 필요한 개수만큼만 뽑아내는 거 취지에 맞게 연습 하길 바람

----

이진 검색 시험에 나올 수 있으니까 잘 이해하길 바란다

알고리즘 과목 평가 -> 3문제

이 중에 2문제는 코드를 짜는 문제(지금 우리가 푸는 문제처럼 지문 주고, 예시 입력 출력 예시 주고 지문을 보고 , 들어오는 입력에 따라 들어오는 코드 작성해서 내기)

나머지 한 문제는 서술형 문제 (문제에 기술이 되어있음 (선택정렬 예시를 주고 어떻게 되는지 설명하시오, 정렬 알고리즘을 설명하시오 등, 아니면 이진 검색에 대해서 상황을 주고 어떻게 동작하는지, 쓰라는지 한 문제는 서술형이고 두 문제는 코드를 작성 문제마다 배점이 틀린데 두 문제 중에, 난이도가 하나는 상대적으로 쉽고 하나는 상대적으로 어렵다? 보는 사람에 따라서 둘 다 쉽고 어려울 수 있는데 배점이 좀 다르죠))



시간복잡도가 나올수도 잇을듯?(늘 최악의 경우를 표현함)

평균적으로 보면 





알고리즘 과목 평가 : 3문제 (list1, list2가 주)

알고리즘 이해, 구현이 가능해야 함

2문제 : 코드를 짜는 문제

(두 문제 중에, 난이도가 하나는 상대적으로 쉽고 하나는 상대적으로 어렵다, 배점 차이 O)

- 지문 (입출력 예시 제시) 에 맞춰 코드 작성

1문제 : 서술형 

ex) 1. 선택정렬 예시를 주고 어떻게 되는지 설명하시오

​	  2. 정렬 알고리즘을 설명하시오

	  3. 이진 검색에 대해서 상황을 주고 어떻게 동작하는지, 쓰라는지



---





이진 검색에서 중요하게 기억해야 될 것은

!! 중요 !!

```
이진 탐색을 하기 위해서는 자료가 반드시! 정렬된 상태여야 한다.
```

```
중간값을 찍고 절반에 해당하는 것을 삭제해야 한다면, 찾는 값이 있을 수 없다고 보장해야 하기 때문에 반드시 정렬
```

```
정렬에도 비용이 들지 않는가?
정렬하는데에도 비용이 필요함
따로 뒤에가서도 이야기가 나올텐데
검색을 하려는 데이터가 변화가 없ㅇ
```







```
```





-------------------









이진탐색 게임 ㅋㅋ

이진탐색으로 쪽 번호까지 감

1, 400 -> 처음에 찾을 구간

중간 페이지 (l+r)/2

찾는 쪽 번호가 c와 같아지면 탐색을 끝낸다



---

선택정렬

문제 접근 위한 약간의 설명쓰~





반복 내부에서부터 먼저 생각

작은 수대로 나열하기

1)제일 작은 수 하나만 찾아보기

min_num = 0

for i in range(1,N):

​		if arr[min_num] > arr[i]:

​				min_idx = i

arr[0], arr[min_idx] = arr[min_idx], add[0]



```python
min_idx = 0 #시작
for i in range(1,N):
    if arr[min_num] > arr[i]:
        min_idx = i
arr[0], arr[min_idx] = arr[min_idx],  add[0]

print(arr)

min_idx = 1
for i in range(2,N):
    if arr[min_num] > arr[i]:
        min_idx = i
arr[1], arr[min_idx] = arr[min_idx],  add[1]

print(arr)

min_idx = 2 #i네?
for i in range(3,N): #범위는 i+1부터 도네?
    if arr[min_num] > arr[i]:
        min_idx = i
arr[2], arr[min_idx] = arr[min_idx],  add[2]

print(arr)

```

-> 이런식으루 ,, ^^



```python
arr = [64, 25, 10, 22, 11]
N = len(arr)

for i in range(N-1):
    min_idx = i
    for j in range(i+1, N):
        if arr[min_num] > arr[j]:
            min_num = j
    arr[i], arr[min_num] = arr[min_num], arr[i]
 

print(arr)
```









사다리 문제 2차 배열

4문제 먼저 풀어보고 사다리 풀어보기



역으로 풀기, 가운데 있을 때 좌우로 움직일 때



거꾸로 밑에서 올라오는게 효율적

왼쪽, 오른쪽이든 먼저 움직일텐데

지나오는 걸 다시 되돌아 가는 걸 방지

















[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],

[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 

[0, 0, 1, 1, 1, 0, 0, 0, 0, 0],

[0, 0, 1, 1, 1, 0, 0, 0, 0, 0], 

[0, 0, 1, 1, 1, 0, 0, 0, 0, 0],

[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],

[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],

[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]

[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],

 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]



[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]

[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 

[0, 0, 1, 1, 1, 0, 0, 0, 0, 0], 

[0, 0, 1, 1, 1, 1, 1, 0, 0, 0], 

[0, 0, 1, 1, 1, 1, 1, 0, 0, 0], 

[0, 0, 0, 1, 1, 1, 1, 0, 0, 0], 

[0, 0, 0, 1, 1, 1, 1, 0, 0, 0], 

[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 

[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 

[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]



[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 

[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 

[0, 0, 1, 1, 1, 0, 0, 0, 0, 0], 

[0, 0, 1, 2, 2, 2, 2, 0, 0, 0], 

[0, 0, 1, 2, 2, 2, 2, 0, 0, 0], 

[0, 0, 0, 2, 2, 2, 2, 0, 0, 0], 

[0, 0, 0, 2, 2, 2, 2, 0, 0, 0], 

[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 

[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 

[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]







```
p, a, b = list(map(int, input().split()))
 s = 1
 e = p
 a_count = 0
 while s <= e:
    mid = (s + e) // 2
    
    if mid == A:
     break
     elif mid > A:
         e = mid
         a_count += 1
     else:
         s = mid
         a_count += 1
        
    s = 1
    e = len(P)
    while s <= e:
         mid = (s + e) // 2
    if P[mid] == B:
        break
     elif P[mid] > B:
        e = mid
        a_count += 1
     else:
         s = mid
         a_count += 1
```



