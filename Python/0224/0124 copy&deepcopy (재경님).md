# 변수_ 얕은복사_ 깊은복사

## mutable와  immutable

> mutable: 데이터의 값을 변화시킬 수 있다.
>
> immutable: 데이터의 값을 변화시킬 수 없다. 

<br>

| 자료형의 타입 | 변화 가능 여부 |
| ------------- | -------------- |
| list          | O (mutable)    |
| set           | O (mutable)    |
| dict          | O (mutable)    |
| int           | X (immutable)  |
| float         | X (immutable)  |
| str           | X (immutable)  |
| bool          | X (immutable)  |
| tuple         | X (immutable)  |

<br>

- 파이썬에서 변수에 값을 할당할 때 , 데이터를 직접적으로 변수에 저장하는 것이 아니다.

  변수는 데이터가 저장되어 있는 장소를 가리킴으로서 데이터를 참조한다. 

```python
# a는 '파이썬'이 저장되어 있는 메모리(객체)를 참조하고 있는 것이다. 
# 즉, a는 '파이썬'이라는 문자열을 저장한 것이 아닌 '파이썬'문자열이 위치한 저장장소를 가리키고 있다. 
a = '파이썬' 
    
print(id(a)) # 2302767247600
print(id('파이썬')) # 2302767247600
```



- 변수에 다른 변수를 할당하면( ex. `b = a` ) 다른 변수(`a`)가 참조하고 있었던 객체를 할당한다. 
  즉, 두 변수가 참조하고 있는 메모리는 동일하다.  

```python
a = '파이썬' # a는 '파이썬'객체를 참조한다.
b = a # b는 '파이썬'객체를 참조한다. 

print(a, b) # 파이썬 파이썬
print(id(a), id(b)) # 2816319140080 2816319140080 // 동일한 위치를 참조하고 있는 것을 확인할 수 있다. 

b = '자바' # b는 '자바'객체를 참조한다.

print(a, b) # 파이썬 자바
print(id(a), id(b)) # 2570547998960 2570548484048 // 둘이 다른 위치를 참조 하고 있다. 

```

<br>

- mutable한 데이터의 경우 객체를 수정할 수 있다. 
  그렇다면 동일한 위치를 참조하고 있는 변수를 수정한다면 어떤 상황이 벌어질까?

```python
a = ['파이썬', '자바', 'C언어']
b = a

print(a, b) # ['파이썬', '자바', 'C언어'] ['파이썬', '자바', 'C언어']
print(id(a), id(b)) # 2162446316096 2162446316096 // 동일한 위치를 참조

b[2] = 'Go' # list 인자를 수정 

#변경된 사항이 참조된 메모리에 적용되어 변수 a의 값도 변한다. 
print(a, b) # ['파이썬', '자바', 'Go'] ['파이썬', '자바', 'Go'] 
print(id(a), id(b)) # 2162446316096 2162446316096


b = ['파이썬'] # 변수에 아예 다른 데이터를 할당. (재할당)

#b는 이제부터 ['파이썬']메모리를 참조하기 때문에 a와 참조하는 메모리가 다르다. 
print(a, b) # ['파이썬', '자바', 'Go'] ['파이썬']
print(id(a), id(b)) # 2162446316096 2162454190464 // 다른 위치를 참조
```

**`b[2] = 'Go'`를 해도 변수a에 영향을 주지 않는 방법이 있을까. 🤔** 

<br>

## 얕은복사

> 얕은 복사는 앞에서 본 list 사례처럼 원본 객체의 메모리(주소)를 복사하는 것을 말한다. 



그래서 이를 해결하기 위해서는 

> 함수나 연산을 통해 똑같은 형태의 새로운 값을 만들어서  다른 주소를 할당한다.
>
> (`b = a`처럼 변수 그대로 할당을 하지 않는다. ) 



### 슬라이싱 활용

```python
a = ['파이썬', '자바', 'C언어']
b = a[::]

print(a, b) # ['파이썬', '자바', 'C언어'] ['파이썬', '자바', 'C언어']
print(id(a), id(b)) # 1760661025344 1760665666496 // 할당하는 메모리가 다름

b[2] = 'Go' # list 인자를 수정 

# 할당하는 메모리가 다르기때문에 원본 변수에 변화를 일으키지 않는다. 
print(a, b) # ['파이썬', '자바', 'C언어'] ['파이썬', '자바', 'Go'] 
print(id(a), id(b)) # 1760661025344 1760665666496
```

<br>

### copy() 메서드 이용

```python
import copy
a = ['파이썬', '자바', 'C언어']
b = copy.copy(a)

print(a, b) # ['파이썬', '자바', 'C언어'] ['파이썬', '자바', 'C언어']
print(id(a), id(b)) # 2502556649792 2502554094016

b[2] = 'Go' 

print(a, b) # ['파이썬', '자바', 'C언어'] ['파이썬', '자바', 'Go']
print(id(a), id(b)) # 2502556649792 2502554094016
```

<br>

### list 형변환

```python
a = ['파이썬', '자바', 'C언어']
b = list(a)

print(a, b) # ['파이썬', '자바', 'C언어'] ['파이썬', '자바', 'C언어']
print(id(a), id(b)) # 1737371562560 1737375829632

b[2] = 'Go' 

print(a, b) # ['파이썬', '자바', 'C언어'] ['파이썬', '자바', 'Go']
print(id(a), id(b)) # 1737371562560 1737375829632
```

<br>

- 그런데 이런 얕은복사는 2차원 리스트와 같이 내부 객체들이 더 존재하는 경우, 내부 객체들의 주소까지 새로 할당하지 않는다. 

```python
a = ['파이썬', '자바', ['C언어', 'Go']]
b = a[::]

print(a[2][0], b[2][0]) # C언어 C언어
print(id(a[2][0]), id(b[2][0])) # 1940742547728 1940742547728 // 내부 객체들은 같은 메모리를 할당한다. 
```

**이런경우 깊은복사를 사용해야 한다.** 

<br>

## 깊은복사

### deep.copy()메서드

내부 객체들까지 새로운 메모리로 ~

```python
import copy
a = ['파이썬', '자바', ['C언어', 'Go']]
b = copy.deepcopy(a)

print(a[2][0], b[2][0]) # C언어 C언어
print(id(a[2][0]), id(b[2][0])) # 1988732004624 1988732004624 // 동일한 값이기 때문에 굳이 새로운 메모리에 할당할 필요가 없음! 그래서 같은 메모리에 위치 

b[2][0] = 'Ruby'

print(a, b) # ['파이썬', '자바', ['C언어', 'Go']] ['파이썬', '자바', ['Ruby', 'Go']]
print(a[2], b[2]) # ['C언어', 'Go'] ['Ruby', 'Go']
print(id(a[2]), id(b[2])) # 2005572651264 2005569176832 // 내부 객체들이 다른 메모리를 할당하는 것을 확인할 수 있다. 
```

